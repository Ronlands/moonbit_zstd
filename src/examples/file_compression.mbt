/// Comprehensive compression and decompression tests

pub fn test_file_compression() -> Unit {
  println("\n" + @zstd_test.repeat_string("=", 60))
  println("å‹ç¼©å’Œè§£å‹ç¼©åŠŸèƒ½æµ‹è¯•")
  println(@zstd_test.repeat_string("=", 60))
  
  test_text_compression()
  test_binary_compression()
  test_large_data_compression()
  test_compression_round_trip()
  
  println("\n" + @zstd_test.repeat_string("=", 60))
  println("å‹ç¼©åŠŸèƒ½æµ‹è¯•å®Œæˆï¼")
  println(@zstd_test.repeat_string("=", 60))
}

/// Text data compression test
fn test_text_compression() -> Unit {
  println("\næµ‹è¯• 1: æ–‡æœ¬æ•°æ®å‹ç¼©")
  println(@zstd_test.repeat_string("-", 40))
  
  let test_text = "Hello, MoonBit ZSTD!\nThis is a test for compression.\næµ‹è¯•ä¸­æ–‡å†…å®¹ã€‚\n"
  let original_data = @encoding/utf8.encode(test_text)
  println("åŸå§‹æ•°æ®å¤§å°: \{original_data.length()} å­—èŠ‚")
  
  let compressed = @zstd.compress(original_data)
  println("å‹ç¼©åå¤§å°: \{compressed.length()} å­—èŠ‚")
  println("å‹ç¼©æ¯”: \{compressed.length().to_double() / original_data.length().to_double()}")
  
  let decompressed = @zstd.decompress(compressed)
  println("è§£å‹åå¤§å°: \{decompressed.length()} å­—èŠ‚")
  
  if original_data.length() == decompressed.length() {
    let mut all_match = true
    for i = 0; i < original_data.length(); i = i + 1 {
      if original_data[i] != decompressed[i] {
        all_match = false
        break
      }
    }
    if all_match {
      println("âœ“ æ•°æ®å®Œæ•´æ€§éªŒè¯: é€šè¿‡")
    } else {
      println("âœ— æ•°æ®å®Œæ•´æ€§éªŒè¯: å¤±è´¥ (å†…å®¹ä¸åŒ¹é…)")
    }
  } else {
    println("âœ— æ•°æ®å®Œæ•´æ€§éªŒè¯: å¤±è´¥ (å¤§å°ä¸åŒ¹é…)")
  }
}

/// Binary data compression test
fn test_binary_compression() -> Unit {
  println("\næµ‹è¯• 2: äºŒè¿›åˆ¶æ•°æ®å‹ç¼©")
  println(@zstd_test.repeat_string("-", 40))
  
  let binary_data : Array[Byte] = []
  for i = 0; i < 1000; i = i + 1 {
    binary_data.push((i % 256).to_byte())
  }
  let original = Bytes::from_array(binary_data)
  println("åŸå§‹æ•°æ®: \{original.length()} å­—èŠ‚")
  
  let compressed = @zstd.compress(original)
  println("å‹ç¼©å: \{compressed.length()} å­—èŠ‚")
  println("èŠ‚çœç©ºé—´: \{100.0 - (compressed.length().to_double() / original.length().to_double() * 100.0)}%")
  
  let decompressed = @zstd.decompress(compressed)
  
  if original == decompressed {
    println("âœ“ å¾€è¿”éªŒè¯: æˆåŠŸ")
  } else {
    println("âœ— å¾€è¿”éªŒè¯: å¤±è´¥")
  }
}

/// Large data compression test (~10KB)
fn test_large_data_compression() -> Unit {
  println("\næµ‹è¯• 3: å¤§æ•°æ®å‹ç¼©")
  println(@zstd_test.repeat_string("-", 40))
  
  let large_data : Array[Byte] = []
  let pattern = @encoding/utf8.encode("ABCDEFGHIJ")
  
  for _i = 0; _i < 1000; _i = _i + 1 {
    for j = 0; j < pattern.length(); j = j + 1 {
      large_data.push(pattern[j])
    }
  }
  
  let original = Bytes::from_array(large_data)
  println("åŸå§‹æ•°æ®: \{original.length()} å­—èŠ‚ (~\{original.length() / 1024}KB)")
  
  let compressed = @zstd.compress(original)
  println("å‹ç¼©å: \{compressed.length()} å­—èŠ‚ (~\{compressed.length() / 1024}KB)")
  println("å‹ç¼©æ¯”: \{original.length().to_double() / compressed.length().to_double()}:1")
  
  let decompressed = @zstd.decompress(compressed)
  
  if original.length() == decompressed.length() {
    println("âœ“ å¤§å°éªŒè¯: é€šè¿‡")
  } else {
    println("âœ— å¤§å°éªŒè¯: å¤±è´¥")
  }
}

/// Round-trip validation test
fn test_compression_round_trip() -> Unit {
  println("\næµ‹è¯• 4: å®Œæ•´å¾€è¿”æµ‹è¯•")
  println(@zstd_test.repeat_string("-", 40))
  
  let test_cases = [
    ("ç©ºæ–‡ä»¶", Bytes::new(0)),
    ("å°æ–‡ä»¶", @encoding/utf8.encode("Small")),
    ("ä¸­ç­‰æ–‡ä»¶", create_test_data(500)),
    ("ç‰¹æ®Šå­—ç¬¦", @encoding/utf8.encode("Hello! ä½ å¥½ï¼ğŸ‰ \n\t\r")),
  ]
  
  let mut passed = 0
  let total = test_cases.length()
  
  for i = 0; i < test_cases.length(); i = i + 1 {
    let (name, data) = test_cases[i]
    
    let compressed = @zstd.compress(data)
    let decompressed = @zstd.decompress(compressed)
    
    if data == decompressed {
      println("  \{name}: âœ“")
      passed = passed + 1
    } else {
      println("  \{name}: âœ— (æ•°æ®ä¸åŒ¹é…)")
    }
  }
  
  println("\nå¾€è¿”æµ‹è¯•é€šè¿‡ç‡: \{passed}/\{total}")
}

