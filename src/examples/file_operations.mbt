/// File Compression and Decompression Operations
/// æ–‡ä»¶å‹ç¼©å’Œè§£å‹ç¼©ç»¼åˆæµ‹è¯•

pub fn test_file_compression() -> Unit {
  println("\n" + @zstd_test.repeat_string("=", 60))
  println("å‹ç¼©å’Œè§£å‹ç¼©åŠŸèƒ½æµ‹è¯•")
  println(@zstd_test.repeat_string("=", 60))
  
  test_text_compression()
  test_binary_compression()
  test_large_data_compression()
  test_compression_round_trip()
  
  println("\n" + @zstd_test.repeat_string("=", 60))
  println("å‹ç¼©åŠŸèƒ½æµ‹è¯•å®Œæˆï¼")
  println(@zstd_test.repeat_string("=", 60))
}

fn test_text_compression() -> Unit {
  println("\næµ‹è¯• 1: æ–‡æœ¬æ•°æ®å‹ç¼©")
  println(@zstd_test.repeat_string("-", 40))
  
  let text = "The quick brown fox jumps over the lazy dog. Hello, MoonBit ZSTD!"
  let original = @encoding/utf8.encode(text)
  let compressed = @zstd.compress(original)
  let decompressed = @zstd.decompress(compressed)
  
  println("åŸå§‹æ•°æ®å¤§å°: \{original.length()} å­—èŠ‚")
  println("å‹ç¼©åå¤§å°: \{compressed.length()} å­—èŠ‚")
  println("å‹ç¼©æ¯”: \{compressed.length().to_double() / original.length().to_double()}")
  println("è§£å‹åå¤§å°: \{decompressed.length()} å­—èŠ‚")
  
  if original == decompressed {
    println("âœ“ æ•°æ®å®Œæ•´æ€§éªŒè¯: é€šè¿‡")
  } else {
    println("âœ— æ•°æ®å®Œæ•´æ€§éªŒè¯: å¤±è´¥")
  }
}

fn test_binary_compression() -> Unit {
  println("\næµ‹è¯• 2: äºŒè¿›åˆ¶æ•°æ®å‹ç¼©")
  println(@zstd_test.repeat_string("-", 40))
  
  let original = create_binary_data(1000)
  let compressed = @zstd.compress(original)
  let decompressed = @zstd.decompress(compressed)
  
  let savings = if compressed.length() < original.length() {
    ((original.length() - compressed.length()) * 100 / original.length()).to_double() / 100.0
  } else {
    -((compressed.length() - original.length()) * 100 / original.length()).to_double() / 100.0
  }
  
  println("åŸå§‹æ•°æ®: \{original.length()} å­—èŠ‚")
  println("å‹ç¼©å: \{compressed.length()} å­—èŠ‚")
  println("èŠ‚çœç©ºé—´: \{(savings * 100.0).to_int()}%")
  
  if original == decompressed {
    println("âœ“ å¾€è¿”éªŒè¯: æˆåŠŸ")
  } else {
    println("âœ— å¾€è¿”éªŒè¯: å¤±è´¥")
  }
}

fn test_large_data_compression() -> Unit {
  println("\næµ‹è¯• 3: å¤§æ•°æ®å‹ç¼©")
  println(@zstd_test.repeat_string("-", 40))
  
  let original = create_binary_data(10000)
  let compressed = @zstd.compress(original)
  let decompressed = @zstd.decompress(compressed)
  
  let ratio = original.length().to_double() / compressed.length().to_double()
  
  println("åŸå§‹æ•°æ®: \{original.length()} å­—èŠ‚ (~\{original.length() / 1024}KB)")
  println("å‹ç¼©å: \{compressed.length()} å­—èŠ‚ (~\{compressed.length() / 1024}KB)")
  println("å‹ç¼©æ¯”: \{ratio}:1")
  
  if original == decompressed {
    println("âœ“ å¤§å°éªŒè¯: é€šè¿‡")
  } else {
    println("âœ— å¤§å°éªŒè¯: å¤±è´¥")
  }
}

fn test_compression_round_trip() -> Unit {
  println("\næµ‹è¯• 4: å®Œæ•´å¾€è¿”æµ‹è¯•")
  println(@zstd_test.repeat_string("-", 40))
  
  let tests = [
    ("ç©ºæ–‡ä»¶", Bytes::new(0)),
    ("å°æ–‡ä»¶", @encoding/utf8.encode("Small")),
    ("ä¸­ç­‰æ–‡ä»¶", create_binary_data(500)),
    ("ç‰¹æ®Šå­—ç¬¦", @encoding/utf8.encode("ğŸ˜€ğŸ‰âœ“âœ—â†’"))
  ]
  
  let mut passed = 0
  for i = 0; i < tests.length(); i = i + 1 {
    let (name, data) = tests[i]
    let compressed = @zstd.compress(data)
    let decompressed = @zstd.decompress(compressed)
    
    if data == decompressed {
      println("  \{name}: âœ“")
      passed = passed + 1
    } else {
      println("  \{name}: âœ—")
    }
  }
  
  println("\nå¾€è¿”æµ‹è¯•é€šè¿‡ç‡: \{passed}/\{tests.length()}")
}

fn create_binary_data(size: Int) -> Bytes {
  let arr: Array[Byte] = []
  for i = 0; i < size; i = i + 1 {
    arr.push(((i * 7 + 13) % 256).to_byte())
  }
  Bytes::from_array(arr)
}


