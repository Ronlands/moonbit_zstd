/// Finite State Entropy (FSE) decoder implementation
/// Used for decoding sequence distributions (Literal Lengths, Match Lengths, Offsets)
/// Following RFC 8878 specification
///
/// TODO: å®ç° FSE ç¼–ç å™¨
/// - [ ] FSE è¡¨æ„å»ºï¼ˆç”¨äºç¼–ç ï¼‰
/// - [ ] FSE ç¬¦å·ç¼–ç 
/// - [ ] æƒé‡å½’ä¸€åŒ–ç®—æ³•
/// - [ ] è¡¨åºåˆ—åŒ–è¾“å‡º

/// Sequence structure
pub struct Sequence {
  literal_length: Int
  match_length: Int
  offset: Int
} derive(Default)

/// Create new sequence
pub fn make_sequence(literal_length: Int, match_length: Int, offset: Int) -> Sequence {
  Sequence::{ literal_length, match_length, offset }
}

/// FSEè¡¨ç»“æ„
pub struct FSETable {
  symbols: Array[Int]
  num_bits: Array[Int]
  table_log: Int
  max_symbol: Int
  total_count: Int
} derive(Default)

/// FSEçŠ¶æ€
pub struct FSEState {
  state: Int
  table: FSETable
} derive(Default)

/// åˆ›å»ºç©ºçš„FSEè¡¨
pub fn create_fse_table() -> FSETable {
  FSETable::{
    symbols: [],
    num_bits: [],
    table_log: 0,
    max_symbol: 0,
    total_count: 0
  }
}

/// åˆ›å»ºFSEè¡¨
pub fn create_fse_table_with_params(
  symbols: Array[Int],
  num_bits: Array[Int],
  table_log: Int,
  max_symbol: Int,
  total_count: Int
) -> FSETable {
  FSETable::{ symbols, num_bits, table_log, max_symbol, total_count }
}

/// è§£æFSEæƒé‡å¹¶æ„å»ºè¡¨
pub fn build_fse_table_from_weights(weights: Array[Int], table_log: Int) -> Result[FSETable, String] {
  let max_symbol = weights.length() - 1
  let mut total_count = 0
  
  // è®¡ç®—æ€»æƒé‡
  for i = 0; i < weights.length(); i = i + 1 {
    total_count = total_count + weights[i]
  }
  
  if total_count == 0 {
    return Err("æ‰€æœ‰æƒé‡éƒ½ä¸ºé›¶")
  }
  
  // è®¡ç®—å½’ä¸€åŒ–å› å­
  let scale = (1 << table_log) / total_count
  let normalized_weights: Array[Int] = []
  let symbols: Array[Int] = []
  let num_bits: Array[Int] = []
  
  // å½’ä¸€åŒ–æƒé‡
  for i = 0; i < weights.length(); i = i + 1 {
    let normalized = (weights[i] * scale).max(1)
    normalized_weights.push(normalized)
  }
  
  // æ„å»ºç¬¦å·è¡¨
  for i = 0; i < weights.length(); i = i + 1 {
    for _j = 0; _j < normalized_weights[i]; _j = _j + 1 {
      symbols.push(i)
    }
  }
  
  // è®¡ç®—æ¯ä¸ªç¬¦å·çš„ä½æ•°
  for i = 0; i < weights.length(); i = i + 1 {
    if normalized_weights[i] > 0 {
      // ç®€å•çš„å¯¹æ•°è¿‘ä¼¼ï¼šlog2(x) â‰ˆ 31 - clz(x)
      let weight = normalized_weights[i]
      let bits = if weight <= 0 { 0 } else { table_log - (31 - weight.clz()) }
      num_bits.push(bits.max(1))
    } else {
      num_bits.push(0)
    }
  }
  
  Ok(create_fse_table_with_params(symbols, num_bits, table_log, max_symbol, total_count))
}

/// åˆ›å»ºFSEçŠ¶æ€
pub fn create_fse_state(table: FSETable) -> FSEState {
  FSEState::{ state: 0, table: table }
}

/// åˆå§‹åŒ–FSEçŠ¶æ€
pub fn init_fse_state(state: FSEState, initial_value: Int) -> FSEState {
  FSEState::{ state: initial_value, table: state.table }
}

/// ä»ä½æµä¸­è¯»å–FSEå€¼
pub fn fse_decode_symbol(state: FSEState, bitstream: Bytes, bit_pos: Int) -> Result[(Int, Int, Int), String] {
  let table = state.table
  let state_value = state.state
  
  if state_value >= table.symbols.length() {
    return Err("FSEçŠ¶æ€å€¼è¶…å‡ºèŒƒå›´")
  }
  
  let symbol = table.symbols[state_value]
  let bits_to_read = if symbol < table.num_bits.length() { table.num_bits[symbol] } else { 1 }
  
  // ä»ä½æµä¸­è¯»å–ä½æ•°
  let mut new_state = 0
  let mut current_bit_pos = bit_pos
  for i = 0; i < bits_to_read; i = i + 1 {
    let byte_pos = current_bit_pos / 8
    let bit_offset = current_bit_pos % 8
    
    if byte_pos >= bitstream.length() {
      return Err("ä½æµæ•°æ®ä¸è¶³")
    }
    
    let bit = (bitstream[byte_pos].to_int() >> bit_offset) & 1
    new_state = new_state | (bit << i)
    current_bit_pos = current_bit_pos + 1
  }
  
  Ok((symbol, new_state, current_bit_pos))
}

/// æ‰¹é‡è§£ç FSEå€¼
pub fn fse_decode_multiple(
  table: FSETable,
  bitstream: Bytes,
  bit_pos: Int,
  count: Int
) -> Result[(Array[Int], Int), String] {
  let result: Array[Int] = []
  let mut state = create_fse_state(table)
  let mut current_bit_pos = bit_pos
  
  for _i = 0; _i < count; _i = _i + 1 {
    let decode_result = fse_decode_symbol(state, bitstream, current_bit_pos)
    match decode_result {
      Ok((symbol, new_state, new_bit_pos)) => {
        result.push(symbol)
        state = FSEState::{ state: new_state, table: table }
        current_bit_pos = new_bit_pos
      }
      Err(e) => return Err(e)
    }
  }
  
  Ok((result, current_bit_pos))
}

/// è§£æFSEè¡¨å¤´
pub fn parse_fse_table_header(data: Bytes, offset: Int) -> Result[(Array[Int], Int, Int), String] {
  if offset >= data.length() {
    return Err("FSEè¡¨å¤´æ•°æ®ä¸è¶³")
  }
  
  let header_byte = data[offset].to_int()
  let accuracy_log = (header_byte & 0x0F) + 5  // 5-12
  let table_log = accuracy_log.min(12)
  
  let mut current_offset = offset + 1
  let weights: Array[Int] = []
  
  // è§£ææƒé‡
  let mut i = 0
  while i < 256 && current_offset < data.length() {
    let weight_byte = data[current_offset].to_int()
    current_offset = current_offset + 1
    
    if weight_byte < 128 {
      // å•å­—èŠ‚æƒé‡
      weights.push(weight_byte)
      i = i + 1
    } else {
      // é‡å¤æƒé‡
      let repeat_count = weight_byte - 128
      let next_byte = if current_offset < data.length() { data[current_offset].to_int() } else { 0 }
      current_offset = current_offset + 1
      
      for _j = 0; _j < repeat_count; _j = _j + 1 {
        weights.push(next_byte)
        i = i + 1
      }
    }
  }
  
  Ok((weights, table_log, current_offset - offset))
}

/// è§£ç FSEå‹ç¼©çš„åºåˆ—
/// ä½¿ç”¨ tANS ä½æµè§£ç ï¼Œä¸ç¼–ç å™¨å®Œå…¨å¯¹é½
pub fn decode_fse_sequences(
  data: Bytes,
  offset: Int,
  num_sequences: Int,
  ll_weights: Array[Int],
  ml_weights: Array[Int],
  of_weights: Array[Int]
) -> Result[Array[Sequence], String] {
  // ç¦ç”¨è¿‡å¤šè°ƒè¯•è¾“å‡º
  // println("ğŸ” FSEè§£ç å¼€å§‹: num_sequences=\{num_sequences}, offset=\{offset}")
  
  if num_sequences == 0 {
    return Ok([])
  }
  
  // æ„å»ºFSEè§£ç è¡¨
  let ll_dtable = build_fse_dtable(ll_weights, 6)
  let ml_dtable = build_fse_dtable(ml_weights, 6)
  let of_dtable = build_fse_dtable(of_weights, 5)
  
  // åˆ›å»ºä½æµè§£ç å™¨
  // âš ï¸ å…³é”®ï¼štANSæœ€ç»ˆçŠ¶æ€åœ¨ä½æµæœ«å°¾ï¼
  // éœ€è¦å…ˆè¯»å–æœ«å°¾çš„æœ€ç»ˆçŠ¶æ€ï¼ˆ17ä½ï¼šLL 6ä½ + ML 6ä½ + OF 5ä½ï¼‰
  // ç„¶åå†ä»å‰é¢è§£ç ç¬¦å·æ•°æ®
  
  // åˆå§‹åŒ–DStream
  let fse_data_len = data.length() - offset
  if fse_data_len < 1 {
    return Err("FSE data too short")
  }
  
  // åˆå§‹åŒ– bitstreamï¼ˆå‚ç…§å®˜æ–¹ BIT_initDStreamï¼‰
  let bitstream = BitstreamReader::{
    data: data,
    offset: 0,
    bit_container: 0UL,
    bit_pos: 0,
    end_offset: offset
  }
  
  let temp_bs = bitstream
  
  if fse_data_len >= 8 {
    // âœ… Normal case: å®Œå…¨å‚ç…§å®˜æ–¹ bitstream.h:261-266
    // ptr = srcBuffer + srcSize - sizeof(bitContainer)
    temp_bs.offset = offset + fse_data_len - 8
    
    // bitContainer = MEM_readLEST(ptr) - è¯»å–8å­—èŠ‚little-endian
    let mut container = 0UL
    for i = 0; i < 8; i = i + 1 {
      let byte_val = data[temp_bs.offset + i].to_uint64()
      container = container | (byte_val << (i * 8))
      if num_sequences == 9 && i < 8 {
        println("    data[\{temp_bs.offset + i}] = \{data[temp_bs.offset + i].to_int()}")
      }
    }
    temp_bs.bit_container = container
    
    if num_sequences == 9 {
      println("    bit_containerä½32ä½ = \{(container & 0xFFFFFFFFUL).to_int()}")
    }
    
    // bitsConsumed = lastByte ? 8 - ZSTD_highbit32(lastByte) : 0
    let last_byte_idx = offset + fse_data_len - 1
    let last_byte = data[last_byte_idx].to_int()
    // âš ï¸ å®éªŒæ€§ä¿®å¤ï¼šè°ƒæ•´offsetä½¿å…¶æŒ‡å‘æœ€åå­—èŠ‚
    let bits_consumed_raw = if last_byte == 0 { 0 } else { 8 - highbit32(last_byte) }
    // bits_consumedåº”è¯¥æ˜¯ç›¸å¯¹äº64ä½å®¹å™¨çš„ï¼Œéœ€è¦åŠ ä¸Šåç§»
    let bits_consumed = bits_consumed_raw
    temp_bs.bit_pos = bits_consumed
  } else {
    // âœ… Small data case: å®Œå…¨å‚ç…§å®˜æ–¹ bitstream.h:268-296
    temp_bs.offset = offset
    let mut container = 0UL
    for i = 0; i < fse_data_len; i = i + 1 {
      let byte_val = data[offset + i].to_uint64()
      container = container | (byte_val << (i * 8))
    }
    temp_bs.bit_container = container
    
    let last_byte_idx = offset + fse_data_len - 1
    let last_byte = data[last_byte_idx].to_int()
    let bits_consumed_byte = if last_byte == 0 { 0 } else { 8 - highbit32(last_byte) }
    
    // âœ… å®˜æ–¹ï¼šbitsConsumed += (sizeof(bitContainer) - srcSize)*8
    let extra_bits = (8 - fse_data_len) * 8
    let bits_consumed = bits_consumed_byte + extra_bits
    temp_bs.bit_pos = bits_consumed
  }
  
  // âœ… ä» bitstream è¯»å–åˆå§‹çŠ¶æ€ï¼ˆå‚ç…§å®˜æ–¹ ZSTD_initFseStateï¼‰
  // ç¼–ç å™¨å†™å…¥é¡ºåºï¼ˆä»ä½åˆ°é«˜ï¼‰ï¼šML â†’ OF â†’ LL
  // Bitstreamä»é«˜ä½è¯»å–ï¼Œæ‰€ä»¥è¯»å–é¡ºåºï¼šLL (å…ˆè¯») â†’ OF (ä¸­) â†’ ML (åè¯»)
  
  // Read LL state (6 bits)
  let (bs1, ll_state_raw) = read_bits_uint64(temp_bs, 6)
  
  // Read OF state (5 bits)
  let (bs2, of_state_raw) = read_bits_uint64(bs1, 5)
  
  // Read ML state (6 bits)
  let (bs3, ml_state_raw) = read_bits_uint64(bs2, 6)
  let bs_after_ml_reload = bs3
  
  // åŠ ä¸Š table_size å¾—åˆ°å®Œæ•´çŠ¶æ€
  let ll_s = ll_state_raw + 64UL  // LL table_log=6
  let of_s = of_state_raw + 32UL  // OF table_log=5
  let ml_s = ml_state_raw + 64UL  // ML table_log=6
  
  // è§£ç åºåˆ—ï¼ˆæ­£å‘è§£ç ï¼‰
  let sequences: Array[Sequence] = []
  let mut current_bs = bs_after_ml_reload  // âœ… ä½¿ç”¨æœ€åä¸€æ¬¡reloadåçš„ bitstream
  let mut ll_state = ll_s
  let mut ml_state = ml_s
  let mut of_state = of_s
  
  // æ­£å‘è§£ç ï¼ˆRFC 8878: è¯»å–ç¬¦å·é¡ºåº OF -> ML -> LLï¼Œæ›´æ–°çŠ¶æ€é¡ºåº LL -> ML -> OFï¼‰
  for i = 0; i < num_sequences; i = i + 1 {
    let is_last_seq = (i == num_sequences - 1)
    
    // æŸ¥è¡¨è·å–ç¬¦å·
    let of_e = get_fse_decode_entry(of_state.to_int(), of_dtable, 5)
    let ml_e = get_fse_decode_entry(ml_state.to_int(), ml_dtable, 6)
    let ll_e = get_fse_decode_entry(ll_state.to_int(), ll_dtable, 6)

    let of_code = match of_e {
      Some(entry) => entry.symbol
      None => 0
    }
    let ml_code = match ml_e {
      Some(entry) => entry.symbol
      None => 0
    }
    let ll_code = match ll_e {
      Some(entry) => entry.symbol
      None => 0
    }
    
    let (of_entry, ml_entry, ll_entry) = if is_last_seq {
      (None, None, None)
    } else {
      (of_e, ml_e, ll_e)
    }
    
    // è¯»å–é¢å¤–ä½ï¼ˆå‚ç…§å®˜æ–¹ line 1294, 1326, 1335ï¼šOF â†’ ML â†’ LLï¼‰
    let of_nb_bits = get_of_bits(of_code)
    let ml_nb_bits = get_ml_bits(ml_code)
    let ll_nb_bits = get_ll_bits(ll_code)
    
    // OF extra bits
    let (bs_tmp1, of_extra_bits) = read_bits_uint64(current_bs, of_nb_bits)
    
    // ML extra bits  
    let (bs_tmp2, ml_extra_bits) = read_bits_uint64(bs_tmp1, ml_nb_bits)
    
    // LL extra bits (æš‚æ—¶ç¦ç”¨ä¸­é—´reloadæµ‹è¯•)
    let (bs_after_ll, ll_extra_bits) = read_bits_uint64(bs_tmp2, ll_nb_bits)
    
    // æ­¥éª¤3: å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªåºåˆ—ï¼ŒæŒ‰ LL -> ML -> OF çš„é¡ºåºæ›´æ–°çŠ¶æ€
    let final_bs = if !is_last_seq {
      let (bs1, new_ll_state) = match ll_entry {
        Some(entry) => {
          let table_size = 64  // LL table_log = 6
          let (new_bs, extra) = read_bits_uint64(bs_after_ll, entry.nb_bits)
          let new_state = entry.new_state_base + extra.to_int() + table_size
          (new_bs, new_state)
        }
        None => (bs_after_ll, 64)
      }
      
      let (bs2, new_ml_state) = match ml_entry {
        Some(entry) => {
          let table_size = 64  // ML table_log = 6
          let (new_bs, extra) = read_bits_uint64(bs1, entry.nb_bits)
          let new_state = entry.new_state_base + extra.to_int() + table_size
          (new_bs, new_state)
        }
        None => (bs1, 64)
      }
      
      let (bs3, new_of_state) = match of_entry {
        Some(entry) => {
          let table_size = 32  // OF table_log = 5
          let (new_bs, extra) = read_bits_uint64(bs2, entry.nb_bits)
          let new_state = entry.new_state_base + extra.to_int() + table_size
          (new_bs, new_state)
        }
        None => (bs2, 32)
      }
      
      // æ›´æ–°çŠ¶æ€å˜é‡
      ll_state = new_ll_state.to_uint64()
      ml_state = new_ml_state.to_uint64()
      of_state = new_of_state.to_uint64()
      
      bs3  // æš‚æ—¶ä¸reload
    } else {
      bs_after_ll
    }
    
    // å°†ç¬¦å·ä»£ç å’Œé¢å¤–ä½è½¬æ¢ä¸ºå®é™…å€¼
    let literal_length = decode_ll(ll_code, ll_extra_bits.to_int())
    let match_length = decode_ml(ml_code, ml_extra_bits.to_int())
    let offset = decode_of(of_code, of_extra_bits.to_int())
    
    if i == 0 && num_sequences == 9 {
      println("  åºåˆ—0è§£ç : ll_code=\{ll_code}+\{ll_extra_bits}=\{literal_length}, ml_code=\{ml_code}+\{ml_extra_bits}=\{match_length}, of_code=\{of_code}+\{of_extra_bits}=\{offset}")
    }
    
    sequences.push(make_sequence(literal_length, match_length, offset))
    current_bs = final_bs
  }
  
  println("  âœ… FSEè§£ç å®Œæˆ: è§£ç äº† \{sequences.length()} ä¸ªåºåˆ—")
  Ok(sequences)
}


/// ä½æµè¯»å–å™¨ï¼ˆç”¨äºè§£ç ï¼Œæ”¯æŒåå‘è¯»å–ï¼‰
priv struct BitstreamReader {
  data: Bytes
  mut offset: Int  // å½“å‰è¯»å–ä½ç½®ï¼ˆåå‘è¯»å–æ—¶ä»é«˜åœ°å€å¾€ä½åœ°å€ï¼‰
  mut bit_container: UInt64
  mut bit_pos: Int  // å½“å‰å®¹å™¨ä¸­å·²ä½¿ç”¨çš„ä½æ•°
  end_offset: Int  // ç»“æŸä½ç½®ï¼ˆä¸åŒ…å«ï¼‰
}

/// Reload bitstreamï¼ˆå®Œå…¨å‚ç…§å®˜æ–¹ BIT_reloadDStream_internalï¼‰
fn reload_bitstream(bs: BitstreamReader) -> BitstreamReader {
  // æ£€æŸ¥æº¢å‡º
  if bs.bit_pos > 64 {
    return bs  // overflow
  }
  
  // âœ… æ— æ¡ä»¶æ‰§è¡Œï¼ˆå®˜æ–¹æ²¡æœ‰æ£€æŸ¥bytes_consumed==0ï¼‰
  // ptr -= bitsConsumed >> 3
  let bytes_consumed = bs.bit_pos / 8
  let new_offset = bs.offset - bytes_consumed
  
  // æ£€æŸ¥è¾¹ç•Œ
  if new_offset < bs.end_offset {
    return bs  // æ— æ³•å¾€å‰ç§»åŠ¨
  }
  
  bs.offset = new_offset
  
  // bitsConsumed &= 7
  bs.bit_pos = bs.bit_pos % 8
  
  // bitContainer = MEM_readLEST(ptr) - é‡æ–°åŠ è½½8å­—èŠ‚
  let mut container = 0UL
  for i = 0; i < 8; i = i + 1 {
    if bs.offset + i < bs.data.length() {
      let byte_val = bs.data[bs.offset + i].to_uint64()
      container = container | (byte_val << (i * 8))
    }
  }
  bs.bit_container = container
  
  bs
}

/// ä»ä½æµè¯»å–æŒ‡å®šä½æ•°ï¼ˆåå‘è¯»å–ï¼šä»é«˜åœ°å€å¾€ä½åœ°å€ï¼‰
fn read_bits_uint64(bs: BitstreamReader, nb_bits: Int) -> (BitstreamReader, UInt64) {
  if nb_bits <= 0 {
    return (bs, 0UL)
  }
  
  // âœ… ç®€åŒ–å®ç°ï¼šè°ƒç”¨è€…è´Ÿè´£æ˜¾å¼reload
  // è¯»å–ä½ï¼ˆä»é«˜ä½å¼€å§‹ï¼Œå‚ç…§å®˜æ–¹ BIT_lookBits + BIT_skipBitsï¼‰
  // start = 64 - bitsConsumed - nbBits
  let start = 64 - bs.bit_pos - nb_bits
  let mask = if nb_bits >= 64 { 0xFFFFFFFFFFFFFFFFUL } else { (1UL << nb_bits) - 1UL }
  let value = (bs.bit_container >> start) & mask
  
  // bitsConsumed += nbBits
  bs.bit_pos = bs.bit_pos + nb_bits
  
  (bs, value)
}


/// åŸºæœ¬FSEæµ‹è¯•
pub fn test_basic_fse() -> Bool {
  let weights: Array[Int] = [1, 2, 3, 4, 5]
  let table_result = build_fse_table_from_weights(weights, 6)
  
  match table_result {
    Ok(table) => table.symbols.length() > 0
    Err(_) => false
  }
}

// ============================================================================
// FSE Encoder Implementation / FSE ç¼–ç å™¨å®ç°
// ============================================================================

// ============================================================================
// BitStream Implementation / ä½æµå®ç°
// ============================================================================

/// ä½æµç»“æ„ - ç”¨äº tANS ç¼–ç è¾“å‡º
pub struct BitStream {
  buffer: Array[Byte]           // è¾“å‡ºç¼“å†²åŒº
  mut bit_container: UInt64     // 64ä½å®¹å™¨
  mut bit_pos: Int              // å®¹å™¨ä¸­çš„ä½ä½ç½® (0-63)
}

/// åˆ›å»ºæ–°çš„ä½æµ
pub fn create_bitstream() -> BitStream {
  BitStream::{
    buffer: [],
    bit_container: 0UL,
    bit_pos: 0
  }
}

/// æ·»åŠ ä½åˆ°ä½æµ
/// value: è¦æ·»åŠ çš„å€¼
/// nb_bits: ä½æ•° (1-64)
pub fn add_bits(stream: BitStream, value: UInt64, nb_bits: Int) -> Unit {
  if nb_bits <= 0 || nb_bits > 64 {
    return
  }
  
  // å°†å€¼æ·»åŠ åˆ°å®¹å™¨
  let mask = if nb_bits >= 64 { 0xFFFFFFFFFFFFFFFFUL } else { (1UL << nb_bits) - 1UL }
  let masked_value = value & mask
  stream.bit_container = stream.bit_container | (masked_value << stream.bit_pos)
  stream.bit_pos = stream.bit_pos + nb_bits
  
  // å¦‚æœå®¹å™¨æ»¡äº†ï¼Œåˆ·æ–°åˆ°ç¼“å†²åŒº
  while stream.bit_pos >= 8 {
    stream.buffer.push((stream.bit_container & 0xFFUL).to_byte())
    stream.bit_container = stream.bit_container >> 8
    stream.bit_pos = stream.bit_pos - 8
  }
}

/// åˆ·æ–°ä½æµï¼ˆè¾“å‡ºå‰©ä½™ä½ï¼‰
pub fn flush_bits(stream: BitStream) -> Unit {
  // å°†å‰©ä½™ä½è¾“å‡º
  while stream.bit_pos > 0 {
    stream.buffer.push((stream.bit_container & 0xFFUL).to_byte())
    stream.bit_container = stream.bit_container >> 8
    stream.bit_pos = (stream.bit_pos - 8).max(0)
  }
}

/// è·å–ä½æµè¾“å‡ºçš„å­—èŠ‚
pub fn get_bytes(stream: BitStream) -> Bytes {
  Bytes::from_array(stream.buffer)
}

/// è·å–ä½æµå½“å‰ä½ç½®ï¼ˆç”¨äºè°ƒè¯•ï¼‰
pub fn get_bitstream_pos(stream: BitStream) -> Int {
  stream.bit_pos
}

/// è·å–ä½æµç¼“å†²åŒºé•¿åº¦ï¼ˆç”¨äºè°ƒè¯•ï¼‰
pub fn get_buffer_length(stream: BitStream) -> Int {
  stream.buffer.length()
}

// ============================================================================
// FSE Encoding Tables / FSE ç¼–ç è¡¨
// ============================================================================

/// ç¬¦å·è½¬æ¢ç»“æ„ - ç”¨äº tANS çŠ¶æ€è½¬æ¢
pub struct SymbolTransform {
  delta_nb_bits: Int      // (maxBitsOut << 16) - minStatePlus
  delta_find_state: Int   // total - normalizedCounter[s]
}

/// FSE ç¼–ç è¡¨ï¼ˆç”¨äºç¼–ç ï¼‰
pub struct FSECTable {
  symbol_tt: Array[SymbolTransform]  // ç¬¦å·è½¬æ¢è¡¨
  state_table: Array[UInt16]         // çŠ¶æ€è¡¨ï¼šå­˜å‚¨ä¸‹ä¸€ä¸ªçŠ¶æ€å€¼ï¼ˆtableSize+uï¼‰
  symbol_table: Array[Int]           // ç¬¦å·æŸ¥æ‰¾è¡¨ï¼šstate -> symbolæ˜ å°„ï¼ˆç”¨äºè§£ç ï¼‰
  table_log: Int                     // Log2 of table size
  normalized: Array[Int]             // å½’ä¸€åŒ–é¢‘ç‡
  max_symbol: Int                    // æœ€å¤§ç¬¦å·å€¼
}

/// FSE è§£ç è¡¨é¡¹
priv struct FSEDecodeEntry {
  symbol: Int        // ç¬¦å·
  nb_bits: Int       // éœ€è¦è¯»å–çš„ä½æ•°
  new_state_base: Int  // æ–°çŠ¶æ€çš„åŸºç¡€å€¼
}

/// æ„å»º FSE è§£ç è¡¨
/// ä¸ºæ¯ä¸ªçŠ¶æ€å€¼ [table_size, 2*table_size) æ„å»ºè§£ç é¡¹
fn build_fse_dtable(normalized: Array[Int], table_log: Int) -> Array[FSEDecodeEntry] {
  let table_size = 1 << table_log
  let dtable: Array[FSEDecodeEntry] = Array::make(table_size, FSEDecodeEntry::{ symbol: 0, nb_bits: 0, new_state_base: 0 })
  
  // ç¬¬ä¸€æ­¥ï¼šæ„å»º table_symbol (spread algorithm) - ä¸ç¼–ç å™¨ç›¸åŒ
  let table_symbol: Array[Int] = Array::make(table_size, 0)
  let mut position = 0
  let step = (table_size >> 1) + (table_size >> 3) + 3
  let mask = table_size - 1
  
  for symbol = 0; symbol < normalized.length(); symbol = symbol + 1 {
    let freq = normalized[symbol]
    // âœ… é¢‘ç‡ -1 è¡¨ç¤ºä½é¢‘ç¬¦å·ï¼ˆé¢‘ç‡ä¸º 1ï¼‰ï¼Œé¢‘ç‡ 0 è¡¨ç¤ºæœªä½¿ç”¨ç¬¦å·
    if freq == 0 { continue }
    
    let actual_freq = if freq == -1 { 1 } else { freq }
    for _i = 0; _i < actual_freq; _i = _i + 1 {
      table_symbol[position] = symbol
      position = (position + step) & mask
    }
  }
  
  // table_symbolæ„å»ºå®Œæˆ
  
  // ç¬¬äºŒæ­¥ï¼šè®¡ç®—æ¯ä¸ªç¬¦å·çš„ç´¯ç§¯ä½ç½® (cumul)
  let cumul: Array[Int] = Array::make(normalized.length() + 1, 0)
  for s = 0; s < normalized.length(); s = s + 1 {
    let norm = normalized[s]
    if norm == -1 {
      cumul[s + 1] = cumul[s] + 1
    } else if norm > 0 {
      cumul[s + 1] = cumul[s] + norm
    } else {
      cumul[s + 1] = cumul[s]
    }
  }
  
  // ç¬¬ä¸‰æ­¥ï¼šæ„å»ºçŠ¶æ€è¡¨ï¼ˆç”¨äºç¼–ç çš„è¡¨ï¼Œæˆ‘ä»¬éœ€è¦åå‘ä½¿ç”¨ï¼‰
  // ä½¿ç”¨ä¸ç¼–ç å™¨ç›¸åŒçš„ç®—æ³•æ„å»º state_table
  let state_table: Array[UInt16] = Array::make(table_size, 0)
  let cumul_copy: Array[Int] = Array::make(normalized.length(), 0)
  for s = 0; s < normalized.length(); s = s + 1 {
    cumul_copy[s] = cumul[s]
  }
  
  for u = 0; u < table_size; u = u + 1 {
    let s = table_symbol[u]
    let idx = cumul_copy[s]
    cumul_copy[s] = idx + 1
    if idx < state_table.length() {
      state_table[idx] = (table_size + u).to_uint16()
    }
  }
  
  // ç¬¬å››æ­¥ï¼šä¸ºæ¯ä¸ªçŠ¶æ€ä½ç½® u æ„å»ºè§£ç é¡¹
  // æ ¹æ® ZSTD å‚è€ƒå®ç°ï¼ˆfse_decompress.cï¼‰
  // symbol_next[s] è·Ÿè¸ªæ¯ä¸ªç¬¦å·çš„"ä¸‹ä¸€ä¸ªçŠ¶æ€å€¼"ï¼Œåˆå§‹åŒ–ä¸ºå½’ä¸€åŒ–é¢‘ç‡
  let symbol_next: Array[Int] = Array::make(normalized.length(), 0)
  for s = 0; s < normalized.length(); s = s + 1 {
    let norm = normalized[s]
    // å¯¹äºé¢‘ç‡ä¸º-1çš„ç¬¦å·ï¼Œè®¾ä¸º1ï¼›å…¶ä»–è®¾ä¸ºå½’ä¸€åŒ–é¢‘ç‡
    symbol_next[s] = if norm == -1 { 1 } else if norm > 0 { norm } else { 0 }
  }
  
  for u = 0; u < table_size; u = u + 1 {
    let symbol = table_symbol[u]
    let next_state = symbol_next[symbol]
    symbol_next[symbol] = next_state + 1
    
    // ZSTD å‚è€ƒå®ç°çš„å…¬å¼:
    // nbBits = tableLog - BIT_highbit32(nextState)
    // newStateBaseline = (nextState << nbBits) - tableSize
    let nb_bits = table_log - highbit32(next_state)
    let new_state_base = (next_state << nb_bits) - table_size
    
    dtable[u] = FSEDecodeEntry::{ 
      symbol: symbol, 
      nb_bits: nb_bits, 
      new_state_base: new_state_base
    }
  }
  
  dtable
}

/// ä½¿ç”¨è§£ç è¡¨ä» FSE çŠ¶æ€è§£ç ç¬¦å·
/// state: å½“å‰çŠ¶æ€ (åœ¨ [table_size, 2*table_size) èŒƒå›´å†…)
/// dtable: è§£ç è¡¨
/// table_log: è¡¨çš„å¯¹æ•°å¤§å°
/// è·å–FSEè§£ç è¡¨é¡¹
fn get_fse_decode_entry(
  state: Int,
  dtable: Array[FSEDecodeEntry],
  table_log: Int
) -> Option[FSEDecodeEntry] {
  let table_size = 1 << table_log
  let u = state - table_size
  
  if u < 0 || u >= dtable.length() {
    println("    âš ï¸ çŠ¶æ€è¶Šç•Œ: state=\{state}, u=\{u}, table_size=\{table_size}")
    None
  } else {
    Some(dtable[u])
  }
}

/// è¿”å›: (new_bitstream, new_state, symbol)
fn decode_fse_symbol_dtable(
  bs: BitstreamReader,
  state: Int,
  dtable: Array[FSEDecodeEntry],
  table_log: Int
) -> (BitstreamReader, Int, Int) {
  let table_size = 1 << table_log
  
  // å°†çŠ¶æ€æ˜ å°„åˆ°è¡¨ç´¢å¼•: u = state - table_size
  let u = state - table_size
  
  // è¾¹ç•Œæ£€æŸ¥
  if u < 0 || u >= dtable.length() {
    println("    âš ï¸ çŠ¶æ€è¶Šç•Œ: state=\{state}, u=\{u}, table_size=\{table_size}")
    return (bs, table_size, 0)  // è¿”å›é»˜è®¤çŠ¶æ€å’Œç¬¦å·
  }
  
  // æŸ¥æ‰¾è§£ç è¡¨é¡¹
  let entry = dtable[u]
  
  // è¯»å–é¢å¤–ä½
  let (new_bs, extra_bits) = read_bits_uint64(bs, entry.nb_bits)
  
  // ZSTD å‚è€ƒå®ç°çš„è§£ç å…¬å¼:
  // new_state = newState + extra_bits + tableSize
  // å…¶ä¸­ newState = (nextState << nbBits) - tableSize (å·²å­˜å‚¨åœ¨è¡¨ä¸­)
  //
  // æ‰€ä»¥: new_state = entry.new_state_base + extra_bits + tableSize
  let new_state = entry.new_state_base + extra_bits.to_int() + table_size
  
  (new_bs, new_state, entry.symbol)
}

/// æ—§çš„ FSE ç¼–ç è¡¨ï¼ˆå…¼å®¹æ€§ï¼‰
pub struct FSEEncodeTable {
  state_table: Array[Int]       // State transition table
  symbol_table: Array[Int]      // Symbol for each state
  num_bits_table: Array[Int]    // Number of bits for each symbol
  next_state_table: Array[Array[Int]]  // Next state for each symbol and bits value
  table_log: Int                // Log2 of table size
  normalized_counts: Array[Int] // Normalized symbol frequencies
  max_symbol: Int               // Maximum symbol value
}

// ============================================================================
// Helper Functions / è¾…åŠ©å‡½æ•°
// ============================================================================

/// è®¡ç®—æœ€é«˜ä½ä½ç½® (log2)
fn highbit32(v: Int) -> Int {
  if v <= 0 { return 0 }
  31 - v.clz()
}

/// æ„å»ºç¬¦å·è½¬æ¢è¡¨
/// æ ¹æ®å½’ä¸€åŒ–é¢‘ç‡æ„å»º tANS çŠ¶æ€è½¬æ¢è¡¨
pub fn build_symbol_transform_table(
  normalized: Array[Int],
  table_log: Int,
  max_symbol: Int
) -> Array[SymbolTransform] {
  let table_size = 1 << table_log
  let symbol_tt: Array[SymbolTransform] = []
  
  // ç¬¬ä¸€éï¼šä¸ºæ¯ä¸ªç¬¦å·åˆ†é…åœ¨çŠ¶æ€è¡¨ä¸­çš„ä½ç½®
  let cumul: Array[Int] = [0]  // cumul[s] = ç¬¦å·såœ¨çŠ¶æ€è¡¨ä¸­çš„èµ·å§‹ä½ç½®
  for s = 0; s <= max_symbol; s = s + 1 {
    let norm = normalized[s]
    if norm == -1 {
      cumul.push(cumul[s] + 1)
    } else if norm >= 1 {
      cumul.push(cumul[s] + norm)
    } else {
      cumul.push(cumul[s])
    }
  }
  
  // ç¬¬äºŒéï¼šæ„å»ºSymbolTransformè¡¨
  // æŒ‰ç…§å®˜æ–¹å®ç°ï¼ˆfse_compress.c:176-200ï¼‰
  let mut total = 0
  for s = 0; s <= max_symbol; s = s + 1 {
    let norm = normalized[s]
    
    if norm == 0 {
      // é›¶é¢‘ç‡ç¬¦å· - ä¸ä¼šè¢«ç¼–ç 
      symbol_tt.push(SymbolTransform::{
        delta_nb_bits: ((table_log + 1) << 16) - table_size,
        delta_find_state: table_size  // è®¾ç½®ä¸ºtable_sizeï¼Œç¡®ä¿ä¸ä¼šè¢«ä½¿ç”¨
      })
    } else if norm == -1 || norm == 1 {
      // ç‰¹æ®Šä½é¢‘ç¬¦å· (-1æˆ–1è¡¨ç¤ºé¢‘ç‡ä¸º1)
      symbol_tt.push(SymbolTransform::{
        delta_nb_bits: (table_log << 16) - table_size,
        delta_find_state: total - 1  // å®˜æ–¹: total - 1
      })
      total = total + 1
    } else {
      // æ­£å¸¸ç¬¦å· (norm > 1)
      let max_bits_out = table_log - highbit32(norm - 1)
      let min_state_plus = norm << max_bits_out
      symbol_tt.push(SymbolTransform::{
        delta_nb_bits: (max_bits_out << 16) - min_state_plus,
        delta_find_state: total - norm  // å®˜æ–¹: total - norm
      })
      total = total + norm
    }
  }
  
  symbol_tt
}

/// æ„å»ºçŠ¶æ€è¡¨ï¼ˆZSTDæ ‡å‡†å®ç°ï¼‰
/// è¿”å›ï¼š(state_table, symbol_table)
/// state_tableå­˜å‚¨çš„æ˜¯ä¸‹ä¸€ä¸ªçŠ¶æ€å€¼ï¼ˆtableSize+uï¼‰ï¼Œsymbol_tableå­˜å‚¨state->symbolæ˜ å°„
fn build_state_table(normalized: Array[Int], table_log: Int) -> (Array[UInt16], Array[Int]) {
  let table_size = 1 << table_log
  let state_table: Array[UInt16] = Array::make(table_size, 0)
  let symbol_table: Array[Int] = Array::make(table_size, 0)
  
  // ç¬¬ä¸€æ­¥ï¼šæ„å»ºtableSymbol - æ¯ä¸ªä½ç½®å¯¹åº”çš„ç¬¦å·
  let table_symbol: Array[Int] = Array::make(table_size, 0)
  let mut position = 0
  let step = (table_size >> 1) + (table_size >> 3) + 3
  let mask = table_size - 1
  
  for symbol = 0; symbol < normalized.length(); symbol = symbol + 1 {
    let freq = normalized[symbol]
    // âœ… é¢‘ç‡ -1 è¡¨ç¤ºä½é¢‘ç¬¦å·ï¼ˆé¢‘ç‡ä¸º 1ï¼‰ï¼Œé¢‘ç‡ 0 è¡¨ç¤ºæœªä½¿ç”¨ç¬¦å·
    if freq == 0 { continue }
    
    let actual_freq = if freq == -1 { 1 } else { freq }
    for _i = 0; _i < actual_freq; _i = _i + 1 {
      table_symbol[position] = symbol
      position = (position + step) & mask
    }
  }
  
  // ç¬¬äºŒæ­¥ï¼šæ„å»ºcumulæ•°ç»„ - æ¯ä¸ªç¬¦å·åœ¨stateTableä¸­çš„èµ·å§‹ä½ç½®
  let cumul: Array[Int] = Array::make(normalized.length() + 1, 0)
  for s = 1; s <= normalized.length(); s = s + 1 {
    let norm = if s - 1 < normalized.length() { normalized[s - 1] } else { 0 }
    cumul[s] = cumul[s - 1] + (if norm == -1 { 1 } else if norm > 0 { norm } else { 0 })
  }
  
  // ç¬¬ä¸‰æ­¥ï¼šå¡«å……stateTable
  for u = 0; u < table_size; u = u + 1 {
    let s = table_symbol[u]
    let idx = cumul[s]
    cumul[s] = idx + 1
    if idx < state_table.length() {
      state_table[idx] = (table_size + u).to_uint16()  // å­˜å‚¨ä¸‹ä¸€ä¸ªçŠ¶æ€å€¼
    }
  }
  
  // ç¬¬å››æ­¥ï¼šå¡«å……symbol_tableï¼ˆu -> symbolæ˜ å°„ï¼Œç”¨äºè§£ç ï¼‰
  // symbol_table[u] = table_symbol[u]ï¼Œå…¶ä¸­uæ˜¯0åˆ°tableSize-1
  for u = 0; u < table_size; u = u + 1 {
    symbol_table[u] = table_symbol[u]
  }
  
  (state_table, symbol_table)
}

/// æ„å»ºå®Œæ•´çš„ FSE ç¼–ç è¡¨
pub fn build_fse_ctable(
  normalized: Array[Int],
  max_symbol: Int,
  table_log: Int
) -> Result[FSECTable, String] {
  if table_log < 5 || table_log > 12 {
    return Err("table_log must be between 5 and 12")
  }
  
  // æ„å»ºç¬¦å·è½¬æ¢è¡¨
  let symbol_tt = build_symbol_transform_table(normalized, table_log, max_symbol)
  
  // æ„å»ºçŠ¶æ€è¡¨å’Œç¬¦å·æŸ¥æ‰¾è¡¨
  let (state_table, symbol_table) = build_state_table(normalized, table_log)
  
  Ok(FSECTable::{
    symbol_tt: symbol_tt,
    state_table: state_table,
    symbol_table: symbol_table,
    table_log: table_log,
    normalized: normalized,
    max_symbol: max_symbol
  })
}

/// ç»Ÿè®¡ç¬¦å·é¢‘ç‡
pub fn count_symbols(data: Array[Int], max_symbol: Int) -> Array[Int] {
  let counts = Array::make(max_symbol + 1, 0)
  for i = 0; i < data.length(); i = i + 1 {
    let symbol = data[i]
    if symbol >= 0 && symbol <= max_symbol {
      counts[symbol] = counts[symbol] + 1
    }
  }
  counts
}

/// å½’ä¸€åŒ–é¢‘ç‡åˆ° 2^tableLog
pub fn normalize_counts(counts: Array[Int], table_log: Int) -> Array[Int] {
  let table_size = 1 << table_log
  let mut total = 0
  
  // è®¡ç®—æ€»é¢‘ç‡
  for i = 0; i < counts.length(); i = i + 1 {
    total = total + counts[i]
  }
  
  if total == 0 {
    return Array::make(counts.length(), 0)
  }
  
  let normalized: Array[Int] = []
  let mut distributed = 0
  
  // å½’ä¸€åŒ–æ¯ä¸ªç¬¦å·çš„é¢‘ç‡
  for i = 0; i < counts.length(); i = i + 1 {
    if counts[i] == 0 {
      normalized.push(0)
    } else {
      // è®¡ç®—å½’ä¸€åŒ–åçš„é¢‘ç‡
      let norm = (counts[i] * table_size) / total
      let final_norm = if norm == 0 { 1 } else { norm }  // è‡³å°‘ä¸º1
      normalized.push(final_norm)
      distributed = distributed + final_norm
    }
  }
  
  // è°ƒæ•´ä»¥ç¡®ä¿æ€»å’Œç­‰äº table_size
  if distributed < table_size {
    // ç»™æœ€é¢‘ç¹çš„ç¬¦å·æ·»åŠ å‰©ä½™
    let mut max_idx = 0
    let mut max_count = counts[0]
    for i = 1; i < counts.length(); i = i + 1 {
      if counts[i] > max_count {
        max_count = counts[i]
        max_idx = i
      }
    }
    normalized[max_idx] = normalized[max_idx] + (table_size - distributed)
  } else if distributed > table_size {
    // ä»æœ€é¢‘ç¹çš„ç¬¦å·å‡å»å¤šä½™
    let mut max_idx = 0
    let mut max_norm = normalized[0]
    for i = 1; i < normalized.length(); i = i + 1 {
      if normalized[i] > max_norm {
        max_norm = normalized[i]
        max_idx = i
      }
    }
    normalized[max_idx] = normalized[max_idx] - (distributed - table_size)
  }
  
  normalized
}

/// æ„å»º FSE ç¼–ç è¡¨ï¼ˆå®Œæ•´çŠ¶æ€æœºå®ç°ï¼‰
pub fn build_fse_encode_table(counts: Array[Int], table_log: Int) -> FSEEncodeTable {
  let normalized = normalize_counts(counts, table_log)
  let table_size = 1 << table_log
  let max_symbol = counts.length() - 1
  
  // çŠ¶æ€è¡¨ï¼šæ¯ä¸ªä½ç½®å¯¹åº”çš„ç¬¦å·
  let symbol_table: Array[Int] = Array::make(table_size, 0)
  
  // ä¸ºæ¯ä¸ªç¬¦å·åˆ†é…çŠ¶æ€
  let mut position = 0
  for symbol = 0; symbol < normalized.length(); symbol = symbol + 1 {
    let count = normalized[symbol]
    for _j = 0; _j < count; _j = _j + 1 {
      if position < table_size {
        symbol_table[position] = symbol
        position = position + 1
      }
    }
  }
  
  // è®¡ç®—æ¯ä¸ªç¬¦å·éœ€è¦çš„ä½æ•°
  let num_bits_table: Array[Int] = Array::make(max_symbol + 1, 0)
  for symbol = 0; symbol <= max_symbol; symbol = symbol + 1 {
    let count = normalized[symbol]
    if count > 0 {
      // num_bits = table_log - log2(count)
      // é™åˆ¶åœ¨åˆç†èŒƒå›´å†…ï¼š0 åˆ° table_log-1
      let log2_count = 31 - count.clz()
      let bits = (table_log - log2_count).max(0).min(table_log - 1)
      num_bits_table[symbol] = bits
    }
  }
  
  // æ„å»ºçŠ¶æ€è½¬æ¢è¡¨ï¼šnext_state_table[symbol][bits_value] = next_state
  let next_state_table: Array[Array[Int]] = []
  for symbol = 0; symbol <= max_symbol; symbol = symbol + 1 {
    let num_bits = num_bits_table[symbol]
    // é™åˆ¶æ•°ç»„å¤§å°ï¼Œé¿å…è¿‡å¤§
    let max_bits_value = if num_bits <= 10 { 1 << num_bits } else { 1024 }
    let state_transitions: Array[Int] = Array::make(max_bits_value, 0)
    
    // ä¸ºæ¯ä¸ªå¯èƒ½çš„ä½å€¼è®¡ç®—ä¸‹ä¸€ä¸ªçŠ¶æ€
    for bits_val = 0; bits_val < max_bits_value; bits_val = bits_val + 1 {
      // ç®€åŒ–çš„çŠ¶æ€è½¬æ¢è®¡ç®—
      let next_state = (normalized[symbol] + bits_val) % table_size
      state_transitions[bits_val] = next_state
    }
    
    next_state_table.push(state_transitions)
  }
  
  FSEEncodeTable::{
    state_table: [],
    symbol_table: symbol_table,
    num_bits_table: num_bits_table,
    next_state_table: next_state_table,
    table_log: table_log,
    normalized_counts: normalized,
    max_symbol: max_symbol
  }
}

/// ä½¿ç”¨ FSE çŠ¶æ€æœºç¼–ç ç¬¦å·åºåˆ—ï¼ˆå®Œæ•´å®ç°ï¼‰
pub fn fse_encode_symbols(symbols: Array[Int], table: FSEEncodeTable) -> Bytes {
  if symbols.length() == 0 {
    return Bytes::from_array([])
  }
  
  // ä½æµè¾“å‡ºç¼“å†²
  let bit_buffer: Array[Int] = []  // å­˜å‚¨ä½å€¼ (0 æˆ– 1)
  
  // åˆå§‹åŒ–çŠ¶æ€ä¸º table_sizeï¼ˆæ ‡å‡† FSE åˆå§‹åŒ–ï¼‰
  let table_size = 1 << table.table_log
  let mut state = table_size
  
  // ç¼–ç æ¯ä¸ªç¬¦å·
  for i = 0; i < symbols.length(); i = i + 1 {
    let symbol = symbols[i]
    
    // ç¡®ä¿ç¬¦å·åœ¨æœ‰æ•ˆèŒƒå›´å†…
    if symbol < 0 || symbol > table.max_symbol {
      continue
    }
    
    // è·å–è¯¥ç¬¦å·éœ€è¦çš„ä½æ•°
    let num_bits = table.num_bits_table[symbol]
    
    // å¦‚æœçŠ¶æ€å¤ªå°ï¼Œè¾“å‡ºä½ç›´åˆ°çŠ¶æ€è¶³å¤Ÿå¤§
    while state < table.normalized_counts[symbol] {
      // è¾“å‡ºæœ€ä½ä½
      bit_buffer.push(state & 1)
      state = state >> 1
    }
    
    // è®¡ç®—è¦è¾“å‡ºçš„ä½å€¼
    let bits_value = state % (1 << num_bits)
    
    // è¾“å‡ºä½å€¼çš„æ¯ä¸€ä½
    for bit_idx = 0; bit_idx < num_bits; bit_idx = bit_idx + 1 {
      let bit = (bits_value >> bit_idx) & 1
      bit_buffer.push(bit)
    }
    
    // æ›´æ–°çŠ¶æ€
    let next_state_idx = bits_value.min(table.next_state_table[symbol].length() - 1)
    state = table.next_state_table[symbol][next_state_idx]
  }
  
  // è¾“å‡ºæœ€ç»ˆçŠ¶æ€
  let final_state_bits = table.table_log
  for bit_idx = 0; bit_idx < final_state_bits; bit_idx = bit_idx + 1 {
    let bit = (state >> bit_idx) & 1
    bit_buffer.push(bit)
  }
  
  // å°†ä½ç¼“å†²è½¬æ¢ä¸ºå­—èŠ‚
  let output: Array[Byte] = []
  let mut byte_val = 0
  let mut bit_count = 0
  
  for i = 0; i < bit_buffer.length(); i = i + 1 {
    let bit = bit_buffer[i]
    byte_val = byte_val | (bit << bit_count)
    bit_count = bit_count + 1
    
    if bit_count == 8 {
      output.push(byte_val.to_byte())
      byte_val = 0
      bit_count = 0
    }
  }
  
  // è¾“å‡ºå‰©ä½™ä½ï¼ˆå¦‚æœæœ‰ï¼‰
  if bit_count > 0 {
    output.push(byte_val.to_byte())
  }
  
  Bytes::from_array(output)
}

/// åºåˆ—åŒ– FSE è¡¨å¤´ï¼ˆå…¼å®¹è§£ç å™¨æ ¼å¼ï¼‰
/// å°†å½’ä¸€åŒ–è®¡æ•°å†™å…¥è¡¨å¤´æ ¼å¼ï¼Œä½¿ç”¨ RLE å‹ç¼©é‡å¤å€¼
pub fn serialize_fse_table(normalized_counts: Array[Int], table_log: Int) -> Bytes {
  let output: Array[Byte] = []
  
  // å†™å…¥è¡¨å¤´ï¼šaccuracy_log - 5ï¼ˆå› ä¸º accuracy_log èŒƒå›´æ˜¯ 5-12ï¼‰
  let accuracy_byte = (table_log - 5) & 0x0F
  output.push(accuracy_byte.to_byte())
  
  // ä½¿ç”¨ RLE å‹ç¼©å†™å…¥å½’ä¸€åŒ–è®¡æ•°
  let mut i = 0
  while i < normalized_counts.length() {
    let count = normalized_counts[i]
    
    // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤å€¼ï¼ˆç”¨äº RLE å‹ç¼©ï¼‰
    let mut repeat_count = 1
    while i + repeat_count < normalized_counts.length() && 
          normalized_counts[i + repeat_count] == count && 
          repeat_count < 127 {
      repeat_count = repeat_count + 1
    }
    
    if repeat_count >= 3 {
      // ä½¿ç”¨ RLEï¼š128 + repeat_countï¼Œç„¶åæ˜¯å€¼
      output.push((128 + repeat_count).to_byte())
      output.push(count.to_byte())
      i = i + repeat_count
    } else {
      // ç›´æ¥ç¼–ç ï¼ˆå°äº 128 çš„å•ä¸ªå€¼ï¼‰
      for _j = 0; _j < repeat_count; _j = _j + 1 {
        if count < 128 {
          output.push(count.to_byte())
        } else {
          // å¤§å€¼éœ€è¦ç‰¹æ®Šå¤„ç†ï¼šæ‹†åˆ†ä¸ºå¤šä¸ªå­—èŠ‚
          let high = count / 128
          let low = count % 128
          output.push(high.to_byte())
          output.push(low.to_byte())
        }
      }
      i = i + repeat_count
    }
  }
  
  Bytes::from_array(output)
}

// ============================================================================
// tANS Encoding / tANS ç¼–ç 
// ============================================================================

/// åˆå§‹åŒ– FSE ç¼–ç çŠ¶æ€
pub fn init_fse_cstate(table: FSECTable) -> UInt64 {
  // åˆå§‹çŠ¶æ€ = table_size
  (1 << table.table_log).to_uint64()
}

/// ç”¨æŒ‡å®šç¬¦å·åˆå§‹åŒ– FSE ç¼–ç çŠ¶æ€
/// ç”¨äºæœ€åä¸€ä¸ªåºåˆ—çš„ç‰¹æ®Šå¤„ç†ï¼ˆå®˜æ–¹ZSTDå®ç°ï¼‰
/// å®˜æ–¹ FSE_initCState2 å®ç°ï¼ˆfse.h ç¬¬ 443-452 è¡Œï¼‰
pub fn init_fse_cstate_with_symbol(table: FSECTable, symbol: Int) -> UInt64 {
  let table_size = 1 << table.table_log
  
  // æ£€æŸ¥ç¬¦å·æœ‰æ•ˆæ€§
  if symbol < 0 || symbol >= table.symbol_tt.length() {
    return table_size.to_uint64()
  }
  
  // ä» symbol_tt è·å–è¯¥ç¬¦å·çš„è½¬æ¢ä¿¡æ¯
  let transform = table.symbol_tt[symbol]
  
  // å®˜æ–¹å®ç°ï¼ˆfse.h:448-450ï¼‰ï¼š
  // U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);
  // statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;
  // statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];
  
  let delta_nb_bits = transform.delta_nb_bits
  let nb_bits_out = ((delta_nb_bits + (1 << 15)) >> 16) & 0xFFFF
  let mut state_value = (nb_bits_out << 16) - delta_nb_bits
  
  // è®¡ç®— stateTable çš„ç´¢å¼•
  let table_idx = (state_value >> nb_bits_out) + transform.delta_find_state
  
  // ä» state_table æŸ¥è¡¨è·å–å®é™…çš„åˆå§‹çŠ¶æ€
  if table_idx >= 0 && table_idx < table.state_table.length() {
    state_value = table.state_table[table_idx].to_int()
  } else {
    // å¦‚æœç´¢å¼•è¶Šç•Œï¼Œä½¿ç”¨é»˜è®¤å€¼
    state_value = table_size + transform.delta_find_state
  }
  
  state_value.to_uint64()
}

/// ç¼–ç å•ä¸ªç¬¦å· (tANS æ ¸å¿ƒç®—æ³•)
/// è¿”å›æ–°çŠ¶æ€
pub fn encode_symbol_fse(
  state: UInt64,
  symbol: Int,
  table: FSECTable,
  bitstream: BitStream
) -> UInt64 {
  if symbol < 0 || symbol > table.max_symbol {
    println("    âš ï¸ ç¬¦å·è¶…å‡ºèŒƒå›´: \{symbol}")
    return state
  }
  
  let transform = table.symbol_tt[symbol]
  
  // è®¡ç®—è¾“å‡ºä½æ•°ï¼šnb_bits_out = (state + delta_nb_bits) >> 16
  let state_int = state.to_int()
  let sum = state_int + transform.delta_nb_bits
  let nb_bits_out = sum >> 16
  
  // è¾“å‡ºä½ï¼ˆçŠ¶æ€çš„ä½ä½ï¼‰
  if nb_bits_out > 0 {
    let mask = if nb_bits_out >= 64 { 0xFFFFFFFFFFFFFFFFUL } else { (1UL << nb_bits_out) - 1UL }
    let bits_to_output = state & mask
    add_bits(bitstream, bits_to_output, nb_bits_out)
  }
  
  // è®¡ç®—æ–°çŠ¶æ€ï¼ˆZSTDæ ‡å‡†tANSç®—æ³•ï¼‰ï¼š
  // new_state = stateTable[(state >> nbBitsOut) + deltaFindState]
  // stateTableå­˜å‚¨çš„æ˜¯çŠ¶æ€å€¼æœ¬èº«ï¼ˆtableSize + uï¼‰
  let base_state = state_int >> nb_bits_out
  let state_idx = base_state + transform.delta_find_state
  
  // ä»stateTableæŸ¥æ‰¾æ–°çŠ¶æ€
  let new_state = if state_idx >= 0 && state_idx < table.state_table.length() {
    table.state_table[state_idx].to_int()
  } else {
    // è¾¹ç•Œä¿æŠ¤ï¼šå¦‚æœç´¢å¼•è¶Šç•Œï¼Œè¿”å›åˆå§‹çŠ¶æ€
    1 << table.table_log
  }
  
  // println("      new_stateæŸ¥è¡¨: stateTable[\{state_idx}] = \{new_state}")
  
  new_state.to_uint64()
}

/// ç¼–ç ç¬¦å·åºåˆ—ï¼ˆtANS å®Œæ•´å®ç°ï¼‰
pub fn fse_encode_sequence(
  symbols: Array[Int],
  table: FSECTable,
  bitstream: BitStream
) -> Result[UInt64, String] {
  if symbols.length() == 0 {
    return Ok(init_fse_cstate(table))
  }
  
  // åˆå§‹åŒ–çŠ¶æ€
  let mut state = init_fse_cstate(table)
  
  // âš ï¸ tANS ç‰¹æ€§ï¼šå€’åºç¼–ç ï¼ˆåè¿›å…ˆå‡ºï¼‰
  // è§£ç å™¨ä¼šä»åå¾€å‰è¯»å–
  let mut i = symbols.length() - 1
  while i >= 0 {
    state = encode_symbol_fse(state, symbols[i], table, bitstream)
    i = i - 1
  }
  
  Ok(state)
}

/// åˆ·æ–°æœ€ç»ˆçŠ¶æ€åˆ°ä½æµ
pub fn flush_final_state(bitstream: BitStream, state: UInt64, table_log: Int) -> Unit {
  // tANS states are in [table_size, 2*table_size), so we normalize by subtracting table_size
  let table_size = 1UL << table_log
  let normalized_state = state - table_size
  // è¾“å‡ºå½’ä¸€åŒ–åçš„çŠ¶æ€ï¼ˆtable_log ä½ï¼‰
  add_bits(bitstream, normalized_state, table_log)
}

/// âœ… FSE ç¼–ç å™¨å®Œæ•´å®ç°ï¼ˆæ–°ç‰ˆæœ¬ï¼Œä½¿ç”¨ tANSï¼‰
/// ç»Ÿè®¡é¢‘ç‡ã€å½’ä¸€åŒ–ã€æ„å»ºè¡¨ã€ç¼–ç ç¬¦å·
pub fn fse_encode_complete_tans(symbols: Array[Int], max_symbol: Int, table_log: Int) -> Result[Bytes, String] {
  if symbols.length() == 0 {
    return Err("Empty symbol sequence")
  }
  
  // 1. ç»Ÿè®¡é¢‘ç‡
  let counts = count_symbols(symbols, max_symbol)
  
  // 2. å½’ä¸€åŒ–
  let normalized = normalize_counts(counts, table_log)
  
  // 3. æ„å»ºç¼–ç è¡¨
  let table_result = build_fse_ctable(normalized, max_symbol, table_log)
  let table = match table_result {
    Ok(t) => t
    Err(e) => return Err(e)
  }
  
  // 4. åºåˆ—åŒ–è¡¨å¤´
  let table_header = serialize_fse_table(normalized, table_log)
  
  // 5. ç¼–ç ç¬¦å·ï¼ˆtANS ä½æµï¼‰
  let bitstream = create_bitstream()
  let final_state = match fse_encode_sequence(symbols, table, bitstream) {
    Ok(s) => s
    Err(e) => return Err(e)
  }
  
  // 6. è¾“å‡ºæœ€ç»ˆçŠ¶æ€
  flush_final_state(bitstream, final_state, table_log)
  
  // 7. åˆ·æ–°ä½æµ
  flush_bits(bitstream)
  
  // 8. åˆå¹¶è¡¨å¤´å’Œæ•°æ®
  let encoded_data = get_bytes(bitstream)
  let result: Array[Byte] = []
  for i = 0; i < table_header.length(); i = i + 1 {
    result.push(table_header[i])
  }
  for i = 0; i < encoded_data.length(); i = i + 1 {
    result.push(encoded_data[i])
  }
  
  Ok(Bytes::from_array(result))
}

/// âœ… FSE ç¼–ç å™¨å®Œæ•´å®ç°ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
/// ç»Ÿè®¡é¢‘ç‡ã€å½’ä¸€åŒ–ã€æ„å»ºè¡¨ã€ç¼–ç ç¬¦å·
pub fn fse_encode_complete(symbols: Array[Int], max_symbol: Int, table_log: Int) -> Result[Bytes, String] {
  fse_encode_complete_tans(symbols, max_symbol, table_log)
}
